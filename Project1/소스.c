#include <stdio.h>    
void main() 
{
	
	}


// 비교 연산자
	// 피연산자를 서로 비교하고, 비교의ㅏ 결과가 참인지에 따라 논리 값을 반환하는 연산자
	// a<b | a>b (서로의 크기를 비교) 결과가   참일 시 1     거짓일 시 0
	// <= | >= (크거나 같고, 작거나 같음) 결과가   참일 시 1     거짓일 시 0
	// == (같음) | != (다름) 결과가   참일 시 1     거짓일 시 0

// 자료형에 대해
/*
// 자료형: 데이터를 저장하기 위해 데이터의 형태를 정해주는 것
// (문자) char: 1바이트 크기, 하나의 문자 저장 가능
// (정수) short: 2바이트 크기, 정수 저장 가능
// (정수) int: 4바이트 크기, 정수 저장 가능
// (정수) long: 운영체제에 따라 4바이트 또는 8바이트 크기, 정수 저장 가능
// long long: 8바이트 또는 그 이상의 크기를 가짐
// (실수) float: 4바이트 크기, 실수 저장 가능
// (실수) double: 8바이트 크기, 실수 저장 가능
// 서식지정자: 출력하기 위한 자료형의 정보를 명시적으로 지정해주는 것
// 변수의 예시 형태 int a = 1; <- a가 변수
// 심볼릭 상수: 메모리 공간을 가지고 있는 상수입니다. 예시) const int b = 2; <- 'const'가 붙은 변수를 변하지 않는 심볼릭 상수가 됨
// 리터럴 상수: 메모리 공간을 가지고 있지 않은 상수입니다. 예시) 그냥 숫자라고 생각하면 됨
// 비트(bit): 데이터를 나타내는 최소의 단위로, 0 또는 1의 값만 저장이 가능함
// 바이트: 1바이트 = 8비트, 한 문자를 나타내기 위한 최소한의 단위
// 10진수를 2진수로 변환하는 과정: 10진수를 1이 될 때까지 계속 2로 나누어 준 다음 나눈 위치의 나머지 값을 아래에서 위로 순서대로 정렬함
// 비트 연산자: 비트 단위로 논리 연산을 수행하기 위해 사용하는 연산자
// 자료형 사진 - https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3921/9904.png
//https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FoJvWv%2FbtqLcUmnNTJ%2Fy6QnSOk0aem6OAJ8YQdKg0%2Fimg.png
*/


	// 산술연산자
	/*
	int a = 10;
	int b = 5;
	printf("a + b = %d \n", a + b);
	printf("a - b = %d \n", a - b);
	printf("a x b = %d \n", a * b);
	printf("a / b = %d \n", a / b);

	int c = a + b;
	int d = a - b;
	int e = a * b;
	int f = a / b;
	printf("a + b = %d \n", c);
	printf("a - b = %d, a x b = %d, a / b = %d \n", d, e, f);

	// 출력하고 싶은 변수의 형태와 서식 지정자가 일치해야만 정확한 값이 나옴
	printf("%c", a);  // 에러는 나지 않지만 변수 형태와 서식 지정자가 불일치하기에 실행해도 아무것도 나오지 않음
	*/

	/*// 심볼릭 상수: 메모리 공간을 가지고 있는 상수입니다.
	// 리터럴 상수: 메모리 공간을 가지고 있지 않은 상수입니다.
    // AND: 2개의 비트가 모두 1일 때 1을 반환  ----- a&b
    // OR: 2개의 비트가 하나라도 1일 때 1을 반환 ----- a|b
    // XOR: 2개의 비트가 서로 같을 때 0을 반환/ 2개의 비트가 서로 다를 때 1을 반환 ----- a^b
    // NOT: 비트를 반전함(0일 때 1을, 1일 때 0을 반환) ----- ~a (2개를 비교하는게 아니라 하나만 함) */

   //오버플로우 언더플로우
	/* // 오버플로우(overflow): 메모리에 표현 범위를 초과하는 수의 값을 저장할 때 발생하는 현상	단, 자료형이 나타낼 수 있는 값과 상수가 더해져 수를 넘어는 경우는 오버플로우 되지 않음
	// 최댓값을 넘어서서 훨씬 더 많은 값을 저장하게 되면 계속 그 범위 내에서 뺑뺑이를 돈다
	// 단, 실수일 때 오버플로우가 발생하면 infinity값이 발생함
	// 언더플로우(underflow): 메모리에 표현 범위를 작은 수의 값을 저장할 때 발생하는 현상	단, 자료형이 실수일 때 언더플로우가 발생 시 값으로 0이 출력됨
	// 오버플로우와 언더플로우는 시계/반시계 방향으로 도는 형태
	// 비트 계산시 [][][][] [][][][] (8비트)중, 제일 앞의 수는 + -를 나타낸다. 1인 경우 -를, 0인 경우 +를 나타낸다. */

	//부호가 없는 자료형
		/*
		unsigned char a = 256;
		printf("a값: %d", a);

		//부호 없는 자료형도 오버/언더 플로우가 존재함
		//unsigned 자료형: 음수를 배제한 자료형 */

//비교 연산
/*int x = 5;
	int y = 10;

	int result1 = x < y;
	int result2 = x > y;
	int result3 = x <= y;
	int result4 = x >= y;
	int result5 = x == y;
	int result6 = x != y;
	printf("result1의 값: %d \n", result1);
	printf("result2의 값: %d \n", result2);
	printf("result3의 값: %d \n", result3);
	printf("result4의 값: %d \n", result4);
	printf("result5의 값: %d \n", result5);
	printf("result6의 값: %d \n", result6);*/

	// 조건문
	/* // 어떠한 조건이 주어질 때 해당 조건에 따라 동작을 실행하는 명령문.
	   */