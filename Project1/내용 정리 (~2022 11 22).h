
// 비교 연산자
	/* // 피연산자를 서로 비교하고, 비교의ㅏ 결과가 참인지에 따라 논리 값을 반환하는 연산자
	// a<b | a>b (서로의 크기를 비교) 결과가   참일 시 1     거짓일 시 0
	// <= | >= (크거나 같고, 작거나 같음) 결과가   참일 시 1     거짓일 시 0
	// == (같음) | != (다름) 결과가   참일 시 1     거짓일 시 0 */

// 자료형에 대해
	/*
	// 자료형: 데이터를 저장하기 위해 데이터의 형태를 정해주는 것
	// (문자) char: 1바이트 크기, 하나의 문자 저장 가능
	// (정수) short: 2바이트 크기, 정수 저장 가능
	// (정수) int: 4바이트 크기, 정수 저장 가능
	// (정수) long: 운영체제에 따라 4바이트 또는 8바이트 크기, 정수 저장 가능
	// long long: 8바이트 또는 그 이상의 크기를 가짐
	// (실수) float: 4바이트 크기, 실수 저장 가능
	// (실수) double: 8바이트 크기, 실수 저장 가능
	// 서식지정자: 출력하기 위한 자료형의 정보를 명시적으로 지정해주는 것
	// 변수의 예시 형태 int a = 1; <- a가 변수
	// 심볼릭 상수: 메모리 공간을 가지고 있는 상수입니다. 예시) const int b = 2; <- 'const'가 붙은 변수를 변하지 않는 심볼릭 상수가 됨
	// 리터럴 상수: 메모리 공간을 가지고 있지 않은 상수입니다. 예시) 그냥 숫자라고 생각하면 됨
	// 비트(bit): 데이터를 나타내는 최소의 단위로, 0 또는 1의 값만 저장이 가능함
	// 바이트: 1바이트 = 8비트, 한 문자를 나타내기 위한 최소한의 단위
	// 10진수를 2진수로 변환하는 과정: 10진수를 1이 될 때까지 계속 2로 나누어 준 다음 나눈 위치의 나머지 값을 아래에서 위로 순서대로 정렬함
	// 비트 연산자: 비트 단위로 논리 연산을 수행하기 위해 사용하는 연산자
	// 자료형 사진 - https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3921/9904.png
	//https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FoJvWv%2FbtqLcUmnNTJ%2Fy6QnSOk0aem6OAJ8YQdKg0%2Fimg.png
	*/

// 산술연산자
	/*
	int a = 10;
	int b = 5;
	printf("a + b = %d \n", a + b);
	printf("a - b = %d \n", a - b);
	printf("a x b = %d \n", a * b);
	printf("a / b = %d \n", a / b);

	int c = a + b;
	int d = a - b;
	int e = a * b;
	int f = a / b;
	printf("a + b = %d \n", c);
	printf("a - b = %d, a x b = %d, a / b = %d \n", d, e, f);

	// 출력하고 싶은 변수의 형태와 서식 지정자가 일치해야만 정확한 값이 나옴
	printf("%c", a);  // 에러는 나지 않지만 변수 형태와 서식 지정자가 불일치하기에 실행해도 아무것도 나오지 않음
	*/
	
//비교
	/* // 심볼릭 상수: 메모리 공간을 가지고 있는 상수입니다.
	// 리터럴 상수: 메모리 공간을 가지고 있지 않은 상수입니다.
	// AND: 2개의 비트가 모두 1일 때 1을 반환  ----- a&b
	// OR: 2개의 비트가 하나라도 1일 때 1을 반환 ----- a|b
	// XOR: 2개의 비트가 서로 같을 때 0을 반환/ 2개의 비트가 서로 다를 때 1을 반환 ----- a^b
	// NOT: 비트를 반전함(0일 때 1을, 1일 때 0을 반환) ----- ~a (2개를 비교하는게 아니라 하나만 함) */

//오버플로우 언더플로우
	 /* // 오버플로우(overflow): 메모리에 표현 범위를 초과하는 수의 값을 저장할 때 발생하는 현상	단, 자료형이 나타낼 수 있는 값과 상수가 더해져 수를 넘어는 경우는 오버플로우 되지 않음
	 // 최댓값을 넘어서서 훨씬 더 많은 값을 저장하게 되면 계속 그 범위 내에서 뺑뺑이를 돈다
	 // 단, 실수일 때 오버플로우가 발생하면 infinity값이 발생함
	 // 언더플로우(underflow): 메모리에 표현 범위를 작은 수의 값을 저장할 때 발생하는 현상	단, 자료형이 실수일 때 언더플로우가 발생 시 값으로 0이 출력됨
	 // 오버플로우와 언더플로우는 시계/반시계 방향으로 도는 형태
	 // 비트 계산시 [][][][] [][][][] (8비트)중, 제일 앞의 수는 + -를 나타낸다. 1인 경우 -를, 0인 경우 +를 나타낸다. */

//부호가 없는 자료형
		  /*
		  unsigned char a = 256;
		  printf("a값: %d", a);

		  //부호 없는 자료형도 오버/언더 플로우가 존재함
		  //unsigned 자료형: 음수를 배제한 자료형 */

// 조건문
			  /* // 어떠한 조건이 주어질 때 해당 조건에 따라 동작을 실행하는 명령문.

			  조건문들의 형태

			  if: if문은 조건이 참이 되지 않으면 조건문 내의 내용이 실행되지 않음

			  else if: if문이 거짓일 경우 실행됨. 마찬가지로 해당 내용도 참이 되지 않을 시 제대로 실행되지 않음

			  else: if문과 if else 둘 다 거짓일 때 실행됨

			  * 만일 if문과 else if문이 모두 참일 시 if문 실행
			  * else if문은 if문과 esle문 사이에 얼마든 추가(선언) 할 수 있음
			  * else문 밑에는 더 이상 else if의 조건문을 설정할 수 없다.
			  * if, if else, else문은 사실상 일종의 세트라 볼 수 있음
			  * if문 선언 시 else if와 else는 추가적인 조건일 뿐, 없어도 실행에는 문제 없음
			  * if문은 독립적인 조건문이기에 if문과 else if 밑에 if를 사용하게 되면 서로 다른 조건문으로 인식함
			  
			  switch: 특정 조건일 때만 실행되는 조건문
			  */

// 논리 연산자
				  /*
				  // 두 개의 논리 값을 연산하여 참 또는 거짓을 결과로 얻는 연산자입니다.

				  // AND (&&)        두 개의 조건이 참이라면 1
				  // OR (||)        두 개 중 하나라도 참이라면 1

				  // NOT (!)        조건문이 거짓이라면 1
				  // bool 변수 = false; 변수가 거짓일 때 참
				  //    변수 = !변수;

				  int x = 10;
				  int y = 20;

				  if (x == 10 && y == 20)
				  {
					  printf("논리 연산 AND의 조건이 성립합니다.\n");
				  }

				  if (x == 10 || y > 30)
				  {
					  printf("논리 연산 OR의 조건이 성립합니다.\n");
				  }

				  if (!(x > 10))
				  {
					  printf("논리 연산 NOT의 조건이 성립합니다.\n");
				  }

// 프로그래밍 표기법
			  /*
			  // 카멜 표기법: 각 단어의 첫 단어를 대문자로 표기하고 붙여 쓰되, 맨 처음 단어는 소문자 표기법
			  // ex) int typeName;
			  // 파스칼 표기법: 첫 단어를 대문자로 시작하는 표기법
			  // ex) int TypeName;
			  // 스네이크 표기법: 단어를 밑줄문자'_(언더바)'로 구분하는 표기법
			  // ex) int type_name;
			  */

// if문 중첩
/*#include <stdio.h>
int main(void)
{
	char alphabet = 'A';

	if (alphabet == 'A')
	{
		if (alphabet != 'B')
		{
			printf("두 번째 조건문이 실행");
		}
	} */

	// 실수를 저장하는 방법
   /*	    float x = 3.6;  // 4바이트  float는 소수점 6자리 이하까지만 정확도 표시
		   double y = 4.6;  // 8바이트  double은 소수점 15자리 이하까지 정확도 표시

		   // 소수점의 자릿수를 설정하려면 ex) %.n(원하는 수)f 이런식으로 해주면 됨
		   printf("x 변수의 값: %.6f \n", x);
		   printf("y 변수의 값: %.15lf \n", y);

		   // IEEE 754 = 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준 표현법
		   */